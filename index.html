<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Drum Set</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
        }

        .container {
            text-align: center;
            padding: 20px;
        }

        h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .subtitle {
            font-size: 1.2rem;
            margin-bottom: 30px;
            opacity: 0.9;
        }

        .drum-set {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            max-width: 800px;
            margin: 0 auto;
        }

        .drum {
            aspect-ratio: 1;
            border-radius: 50%;
            border: 4px solid #333;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.2rem;
            transition: all 0.1s ease;
            position: relative;
            box-shadow: 0 8px 16px rgba(0,0,0,0.3);
        }

        .drum:hover {
            transform: scale(1.05);
            box-shadow: 0 12px 24px rgba(0,0,0,0.4);
        }

        .drum:active {
            transform: scale(0.95);
        }

        .drum.playing {
            animation: drumHit 0.2s ease;
        }

        @keyframes drumHit {
            0% { transform: scale(1); }
            50% { transform: scale(0.9); }
            100% { transform: scale(1); }
        }

        /* Individual drum styles */
        .kick {
            background: linear-gradient(145deg, #8B4513, #A0522D);
            grid-column: 2 / 3;
            grid-row: 3 / 4;
        }

        .snare {
            background: linear-gradient(145deg, #F5F5DC, #DEB887);
            grid-column: 3 / 4;
            grid-row: 2 / 3;
        }

        .hi-hat {
            background: linear-gradient(145deg, #C0C0C0, #A9A9A9);
            grid-column: 1 / 2;
            grid-row: 1 / 2;
        }

        .crash {
            background: linear-gradient(145deg, #FFD700, #FFA500);
            grid-column: 4 / 5;
            grid-row: 1 / 2;
        }

        .tom1 {
            background: linear-gradient(145deg, #CD853F, #D2691E);
            grid-column: 1 / 2;
            grid-row: 2 / 3;
        }

        .tom2 {
            background: linear-gradient(145deg, #CD853F, #D2691E);
            grid-column: 4 / 5;
            grid-row: 2 / 3;
        }

        .floor-tom {
            background: linear-gradient(145deg, #8B4513, #A0522D);
            grid-column: 1 / 2;
            grid-row: 3 / 4;
        }

        .ride {
            background: linear-gradient(145deg, #FFD700, #FFA500);
            grid-column: 3 / 4;
            grid-row: 3 / 4;
        }

        .controls {
            margin-top: 30px;
            display: flex;
            gap: 20px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }

        .control-btn {
            padding: 10px 20px;
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 25px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
        }

        .control-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-2px);
        }

        .volume-slider {
            width: 150px;
            height: 6px;
            border-radius: 3px;
            background: rgba(255,255,255,0.2);
            outline: none;
            -webkit-appearance: none;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
        }

        .volume-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            border: none;
        }

        .instructions {
            margin-top: 20px;
            font-size: 0.9rem;
            opacity: 0.8;
            max-width: 600px;
        }

        @media (max-width: 768px) {
            .drum-set {
                grid-template-columns: repeat(3, 1fr);
                gap: 15px;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .drum {
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŽµ Interactive Drum Set ðŸŽµ</h1>
        <p class="subtitle">Click on any drum or cymbal to play its sound!</p>
        
        <div class="drum-set">
            <div class="drum hi-hat" data-sound="hi-hat">Hi-Hat</div>
            <div class="drum tom1" data-sound="tom1">Tom 1</div>
            <div class="drum snare" data-sound="snare">Snare</div>
            <div class="drum crash" data-sound="crash">Crash</div>
            <div class="drum tom2" data-sound="tom2">Tom 2</div>
            <div class="drum floor-tom" data-sound="floor-tom">Floor Tom</div>
            <div class="drum kick" data-sound="kick">Kick</div>
            <div class="drum ride" data-sound="ride">Ride</div>
        </div>

        <div class="controls">
            <button class="control-btn" id="playAll">Play All</button>
            <button class="control-btn" id="stopAll">Stop All</button>
            <div>
                <label for="volume">Volume: </label>
                <input type="range" id="volume" class="volume-slider" min="0" max="1" step="0.1" value="0.7">
            </div>
        </div>

        <div class="instructions">
            <p><strong>Keyboard Controls:</strong> Press keys 1-8 to play drums, or use your mouse to click on them!</p>
        </div>
    </div>

    <script>
        class DrumSet {
            constructor() {
                this.audioContext = null;
                this.sounds = {};
                this.volume = 0.7;
                this.isInitialized = false;
                this.init();
            }

            async init() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    await this.createSounds();
                    this.setupEventListeners();
                    this.isInitialized = true;
                } catch (error) {
                    console.error('Failed to initialize audio context:', error);
                    alert('Please allow audio permissions to use the drum set!');
                }
            }

            async createSounds() {
                this.sounds = {
                    'kick': this.createRealisticKick(),
                    'snare': this.createRealisticSnare(),
                    'hi-hat': this.createRealisticHiHat(),
                    'crash': this.createRealisticCrash(),
                    'tom1': this.createRealisticTom(220, 0.5),
                    'tom2': this.createRealisticTom(165, 0.6),
                    'floor-tom': this.createRealisticTom(110, 0.8),
                    'ride': this.createRealisticRide()
                };
            }

            createRealisticKick() {
                return () => {
                    const time = this.audioContext.currentTime;
                    
                    // Main body oscillator
                    const bodyOsc = this.audioContext.createOscillator();
                    const bodyGain = this.audioContext.createGain();
                    const bodyFilter = this.audioContext.createBiquadFilter();
                    
                    // Sub-bass oscillator for deep thump
                    const subOsc = this.audioContext.createOscillator();
                    const subGain = this.audioContext.createGain();
                    const subFilter = this.audioContext.createBiquadFilter();
                    
                    // Attack click oscillator
                    const clickOsc = this.audioContext.createOscillator();
                    const clickGain = this.audioContext.createGain();
                    const clickFilter = this.audioContext.createBiquadFilter();
                    
                    // Connect main body
                    bodyOsc.connect(bodyFilter);
                    bodyFilter.connect(bodyGain);
                    bodyGain.connect(this.audioContext.destination);
                    
                    // Connect sub-bass
                    subOsc.connect(subFilter);
                    subFilter.connect(subGain);
                    subGain.connect(this.audioContext.destination);
                    
                    // Connect click
                    clickOsc.connect(clickFilter);
                    clickFilter.connect(clickGain);
                    clickGain.connect(this.audioContext.destination);
                    
                    // Body frequency sweep (realistic kick fundamental)
                    bodyOsc.frequency.setValueAtTime(60, time);
                    bodyOsc.frequency.exponentialRampToValueAtTime(35, time + 0.08);
                    bodyOsc.frequency.exponentialRampToValueAtTime(25, time + 0.3);
                    
                    // Sub-bass for depth
                    subOsc.frequency.setValueAtTime(40, time);
                    subOsc.frequency.exponentialRampToValueAtTime(20, time + 0.15);
                    
                    // Attack click for punch
                    clickOsc.frequency.setValueAtTime(150, time);
                    clickOsc.frequency.exponentialRampToValueAtTime(80, time + 0.01);
                    
                    // Filters
                    bodyFilter.type = 'lowpass';
                    bodyFilter.frequency.setValueAtTime(120, time);
                    bodyFilter.frequency.exponentialRampToValueAtTime(60, time + 0.3);
                    bodyFilter.Q.setValueAtTime(0.8, time);
                    
                    subFilter.type = 'lowpass';
                    subFilter.frequency.setValueAtTime(80, time);
                    subFilter.Q.setValueAtTime(0.5, time);
                    
                    clickFilter.type = 'highpass';
                    clickFilter.frequency.setValueAtTime(100, time);
                    clickFilter.Q.setValueAtTime(1, time);
                    
                    // Gain envelopes
                    bodyGain.gain.setValueAtTime(this.volume * 0.8, time);
                    bodyGain.gain.exponentialRampToValueAtTime(this.volume * 0.4, time + 0.05);
                    bodyGain.gain.exponentialRampToValueAtTime(0.001, time + 0.3);
                    
                    subGain.gain.setValueAtTime(this.volume * 0.6, time);
                    subGain.gain.exponentialRampToValueAtTime(0.001, time + 0.15);
                    
                    clickGain.gain.setValueAtTime(this.volume * 0.3, time);
                    clickGain.gain.exponentialRampToValueAtTime(0.001, time + 0.01);
                    
                    // Start and stop
                    bodyOsc.start(time);
                    subOsc.start(time);
                    clickOsc.start(time);
                    
                    bodyOsc.stop(time + 0.3);
                    subOsc.stop(time + 0.15);
                    clickOsc.stop(time + 0.01);
                };
            }

            createRealisticSnare() {
                return () => {
                    const time = this.audioContext.currentTime;
                    
                    // Drum head oscillator
                    const drumOsc = this.audioContext.createOscillator();
                    const drumGain = this.audioContext.createGain();
                    const drumFilter = this.audioContext.createBiquadFilter();
                    
                    // Snare wires noise
                    const noiseBuffer = this.createNoiseBuffer(0.3, 'pink');
                    const noiseSource = this.audioContext.createBufferSource();
                    const noiseGain = this.audioContext.createGain();
                    const noiseFilter = this.audioContext.createBiquadFilter();
                    const noiseFilter2 = this.audioContext.createBiquadFilter();
                    
                    noiseSource.buffer = noiseBuffer;
                    
                    // Connect drum head
                    drumOsc.connect(drumFilter);
                    drumFilter.connect(drumGain);
                    drumGain.connect(this.audioContext.destination);
                    
                    // Connect snare wires
                    noiseSource.connect(noiseFilter);
                    noiseFilter.connect(noiseFilter2);
                    noiseFilter2.connect(noiseGain);
                    noiseGain.connect(this.audioContext.destination);
                    
                    // Drum head frequency (200Hz is typical snare fundamental)
                    drumOsc.frequency.setValueAtTime(200, time);
                    drumOsc.frequency.exponentialRampToValueAtTime(150, time + 0.1);
                    drumOsc.frequency.exponentialRampToValueAtTime(120, time + 0.2);
                    
                    // Drum head filter
                    drumFilter.type = 'bandpass';
                    drumFilter.frequency.setValueAtTime(400, time);
                    drumFilter.Q.setValueAtTime(2, time);
                    
                    // Snare wire filters
                    noiseFilter.type = 'highpass';
                    noiseFilter.frequency.setValueAtTime(1000, time);
                    noiseFilter.Q.setValueAtTime(1, time);
                    
                    noiseFilter2.type = 'peaking';
                    noiseFilter2.frequency.setValueAtTime(3000, time);
                    noiseFilter2.Q.setValueAtTime(2, time);
                    noiseFilter2.gain.setValueAtTime(6, time);
                    
                    // Gain envelopes
                    drumGain.gain.setValueAtTime(this.volume * 0.5, time);
                    drumGain.gain.exponentialRampToValueAtTime(0.001, time + 0.2);
                    
                    noiseGain.gain.setValueAtTime(this.volume * 0.7, time);
                    noiseGain.gain.exponentialRampToValueAtTime(this.volume * 0.2, time + 0.05);
                    noiseGain.gain.exponentialRampToValueAtTime(0.001, time + 0.25);
                    
                    drumOsc.start(time);
                    noiseSource.start(time);
                    
                    drumOsc.stop(time + 0.2);
                    noiseSource.stop(time + 0.25);
                };
            }

            createRealisticTom(frequency, duration) {
                return () => {
                    const time = this.audioContext.currentTime;
                    
                    // Fundamental frequency
                    const fundOsc = this.audioContext.createOscillator();
                    const fundGain = this.audioContext.createGain();
                    const fundFilter = this.audioContext.createBiquadFilter();
                    
                    // Harmonic oscillator
                    const harmOsc = this.audioContext.createOscillator();
                    const harmGain = this.audioContext.createGain();
                    
                    // Attack transient
                    const attackOsc = this.audioContext.createOscillator();
                    const attackGain = this.audioContext.createGain();
                    const attackFilter = this.audioContext.createBiquadFilter();
                    
                    // Connect fundamental
                    fundOsc.connect(fundFilter);
                    fundFilter.connect(fundGain);
                    fundGain.connect(this.audioContext.destination);
                    
                    // Connect harmonic
                    harmOsc.connect(harmGain);
                    harmGain.connect(this.audioContext.destination);
                    
                    // Connect attack
                    attackOsc.connect(attackFilter);
                    attackFilter.connect(attackGain);
                    attackGain.connect(this.audioContext.destination);
                    
                    // Frequency sweeps
                    fundOsc.frequency.setValueAtTime(frequency, time);
                    fundOsc.frequency.exponentialRampToValueAtTime(frequency * 0.4, time + duration);
                    
                    harmOsc.frequency.setValueAtTime(frequency * 1.5, time);
                    harmOsc.frequency.exponentialRampToValueAtTime(frequency * 0.6, time + duration * 0.7);
                    
                    attackOsc.frequency.setValueAtTime(frequency * 3, time);
                    attackOsc.frequency.exponentialRampToValueAtTime(frequency * 2, time + 0.02);
                    
                    // Filters
                    fundFilter.type = 'lowpass';
                    fundFilter.frequency.setValueAtTime(frequency * 2, time);
                    fundFilter.frequency.exponentialRampToValueAtTime(frequency * 0.8, time + duration);
                    fundFilter.Q.setValueAtTime(1.5, time);
                    
                    attackFilter.type = 'bandpass';
                    attackFilter.frequency.setValueAtTime(frequency * 4, time);
                    attackFilter.Q.setValueAtTime(3, time);
                    
                    // Gain envelopes
                    fundGain.gain.setValueAtTime(this.volume * 0.8, time);
                    fundGain.gain.exponentialRampToValueAtTime(this.volume * 0.3, time + 0.1);
                    fundGain.gain.exponentialRampToValueAtTime(0.001, time + duration);
                    
                    harmGain.gain.setValueAtTime(this.volume * 0.3, time);
                    harmGain.gain.exponentialRampToValueAtTime(0.001, time + duration * 0.7);
                    
                    attackGain.gain.setValueAtTime(this.volume * 0.4, time);
                    attackGain.gain.exponentialRampToValueAtTime(0.001, time + 0.02);
                    
                    fundOsc.start(time);
                    harmOsc.start(time);
                    attackOsc.start(time);
                    
                    fundOsc.stop(time + duration);
                    harmOsc.stop(time + duration * 0.7);
                    attackOsc.stop(time + 0.02);
                };
            }

            createRealisticHiHat() {
                return () => {
                    const time = this.audioContext.currentTime;
                    
                    // Multiple noise sources for metallic character
                    const noise1 = this.createNoiseBuffer(0.15, 'white');
                    const noise2 = this.createNoiseBuffer(0.15, 'white');
                    
                    const source1 = this.audioContext.createBufferSource();
                    const source2 = this.audioContext.createBufferSource();
                    
                    const gain1 = this.audioContext.createGain();
                    const gain2 = this.audioContext.createGain();
                    
                    const filter1 = this.audioContext.createBiquadFilter();
                    const filter2 = this.audioContext.createBiquadFilter();
                    const filter3 = this.audioContext.createBiquadFilter();
                    
                    source1.buffer = noise1;
                    source2.buffer = noise2;
                    
                    source1.connect(filter1);
                    filter1.connect(filter2);
                    filter2.connect(gain1);
                    gain1.connect(this.audioContext.destination);
                    
                    source2.connect(filter3);
                    filter3.connect(gain2);
                    gain2.connect(this.audioContext.destination);
                    
                    // High-frequency emphasis for metallic character
                    filter1.type = 'highpass';
                    filter1.frequency.setValueAtTime(8000, time);
                    filter1.Q.setValueAtTime(0.7, time);
                    
                    filter2.type = 'peaking';
                    filter2.frequency.setValueAtTime(12000, time);
                    filter2.Q.setValueAtTime(2, time);
                    filter2.gain.setValueAtTime(8, time);
                    
                    filter3.type = 'bandpass';
                    filter3.frequency.setValueAtTime(10000, time);
                    filter3.Q.setValueAtTime(3, time);
                    
                    // Sharp attack and quick decay
                    gain1.gain.setValueAtTime(this.volume * 0.6, time);
                    gain1.gain.exponentialRampToValueAtTime(0.001, time + 0.1);
                    
                    gain2.gain.setValueAtTime(this.volume * 0.4, time);
                    gain2.gain.exponentialRampToValueAtTime(0.001, time + 0.08);
                    
                    source1.start(time);
                    source2.start(time);
                    
                    source1.stop(time + 0.1);
                    source2.stop(time + 0.08);
                };
            }

            createRealisticCrash() {
                return () => {
                    const time = this.audioContext.currentTime;
                    const duration = 2.5;
                    
                    // Multiple frequency bands for complex cymbal sound
                    const noise = this.createNoiseBuffer(duration, 'pink');
                    const source = this.audioContext.createBufferSource();
                    
                    const gainMain = this.audioContext.createGain();
                    const filterLow = this.audioContext.createBiquadFilter();
                    const filterMid = this.audioContext.createBiquadFilter();
                    const filterHigh = this.audioContext.createBiquadFilter();
                    
                    source.buffer = noise;
                    
                    source.connect(filterLow);
                    filterLow.connect(filterMid);
                    filterMid.connect(filterHigh);
                    filterHigh.connect(gainMain);
                    gainMain.connect(this.audioContext.destination);
                    
                    // Complex filtering for realistic cymbal
                    filterLow.type = 'highpass';
                    filterLow.frequency.setValueAtTime(400, time);
                    filterLow.Q.setValueAtTime(0.5, time);
                    
                    filterMid.type = 'peaking';
                    filterMid.frequency.setValueAtTime(2500, time);
                    filterMid.frequency.exponentialRampToValueAtTime(1800, time + duration);
                    filterMid.Q.setValueAtTime(1.5, time);
                    filterMid.gain.setValueAtTime(6, time);
                    
                    filterHigh.type = 'peaking';
                    filterHigh.frequency.setValueAtTime(8000, time);
                    filterHigh.Q.setValueAtTime(2, time);
                    filterHigh.gain.setValueAtTime(4, time);
                    
                    // Long decay with shimmer
                    gainMain.gain.setValueAtTime(this.volume * 0.8, time);
                    gainMain.gain.exponentialRampToValueAtTime(this.volume * 0.4, time + 0.2);
                    gainMain.gain.exponentialRampToValueAtTime(0.001, time + duration);
                    
                    source.start(time);
                    source.stop(time + duration);
                };
            }

            createRealisticRide() {
                return () => {
                    const time = this.audioContext.currentTime;
                    const duration = 1.8;
                    
                    // Bell-like oscillator for ping
                    const bellOsc = this.audioContext.createOscillator();
                    const bellGain = this.audioContext.createGain();
                    const bellFilter = this.audioContext.createBiquadFilter();
                    
                    // Noise for wash
                    const noise = this.createNoiseBuffer(duration, 'pink');
                    const noiseSource = this.audioContext.createBufferSource();
                    const noiseGain = this.audioContext.createGain();
                    const noiseFilter = this.audioContext.createBiquadFilter();
                    
                    noiseSource.buffer = noise;
                    
                    // Connect bell
                    bellOsc.connect(bellFilter);
                    bellFilter.connect(bellGain);
                    bellGain.connect(this.audioContext.destination);
                    
                    // Connect wash
                    noiseSource.connect(noiseFilter);
                    noiseFilter.connect(noiseGain);
                    noiseGain.connect(this.audioContext.destination);
                    
                    // Bell frequency (ride ping)
                    bellOsc.frequency.setValueAtTime(1800, time);
                    bellOsc.frequency.exponentialRampToValueAtTime(1600, time + 0.5);
                    
                    bellFilter.type = 'bandpass';
                    bellFilter.frequency.setValueAtTime(2000, time);
                    bellFilter.Q.setValueAtTime(3, time);
                    
                    // Wash filter
                    noiseFilter.type = 'bandpass';
                    noiseFilter.frequency.setValueAtTime(1200, time);
                    noiseFilter.frequency.exponentialRampToValueAtTime(800, time + duration);
                    noiseFilter.Q.setValueAtTime(1.2, time);
                    
                    // Envelopes
                    bellGain.gain.setValueAtTime(this.volume * 0.4, time);
                    bellGain.gain.exponentialRampToValueAtTime(0.001, time + 0.5);
                    
                    noiseGain.gain.setValueAtTime(this.volume * 0.6, time);
                    noiseGain.gain.exponentialRampToValueAtTime(this.volume * 0.3, time + 0.3);
                    noiseGain.gain.exponentialRampToValueAtTime(0.001, time + duration);
                    
                    bellOsc.start(time);
                    noiseSource.start(time);
                    
                    bellOsc.stop(time + 0.5);
                    noiseSource.stop(time + duration);
                };
            }

            createNoiseBuffer(duration, type = 'white') {
                const bufferSize = this.audioContext.sampleRate * duration;
                const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                const output = buffer.getChannelData(0);
                
                if (type === 'white') {
                    for (let i = 0; i < bufferSize; i++) {
                        output[i] = Math.random() * 2 - 1;
                    }
                } else if (type === 'pink') {
                    // Pink noise generation (simplified)
                    let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
                    for (let i = 0; i < bufferSize; i++) {
                        const white = Math.random() * 2 - 1;
                        b0 = 0.99886 * b0 + white * 0.0555179;
                        b1 = 0.99332 * b1 + white * 0.0750759;
                        b2 = 0.96900 * b2 + white * 0.1538520;
                        b3 = 0.86650 * b3 + white * 0.3104856;
                        b4 = 0.55000 * b4 + white * 0.5329522;
                        b5 = -0.7616 * b5 - white * 0.0168980;
                        output[i] = (b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362) * 0.11;
                        b6 = white * 0.115926;
                    }
                }
                
                return buffer;
            }

            playSound(soundName) {
                if (!this.isInitialized || !this.sounds[soundName]) return;
                
                if (this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
                
                try {
                    this.sounds[soundName]();
                    this.animateDrum(soundName);
                } catch (error) {
                    console.error('Error playing sound:', soundName, error);
                }
            }

            animateDrum(soundName) {
                const drum = document.querySelector(`[data-sound="${soundName}"]`);
                if (drum) {
                    drum.classList.add('playing');
                    setTimeout(() => {
                        drum.classList.remove('playing');
                    }, 200);
                }
            }

            setupEventListeners() {
                document.querySelectorAll('.drum').forEach(drum => {
                    drum.addEventListener('click', (e) => {
                        const soundName = e.target.dataset.sound;
                        this.playSound(soundName);
                    });
                });

                // Keyboard events
                const keyMap = {
                    '1': 'hi-hat',
                    '2': 'tom1',
                    '3': 'snare',
                    '4': 'crash',
                    '5': 'tom2',
                    '6': 'floor-tom',
                    '7': 'kick',
                    '8': 'ride'
                };

                document.addEventListener('keydown', (e) => {
                    const soundName = keyMap[e.key];
                    if (soundName) {
                        this.playSound(soundName);
                    }
                });

                // Volume control
                document.getElementById('volume').addEventListener('input', (e) => {
                    this.volume = parseFloat(e.target.value);
                });

                // Play all button
                document.getElementById('playAll').addEventListener('click', () => {
                    const sounds = Object.keys(this.sounds);
                    sounds.forEach((sound, index) => {
                        setTimeout(() => {
                            this.playSound(sound);
                        }, index * 300);
                    });
                });

                // Stop all button
                document.getElementById('stopAll').addEventListener('click', () => {
                    if (this.audioContext) {
                        this.audioContext.close();
                        this.init();
                    }
                });
            }
        }

        // Initialize the drum set when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new DrumSet();
        });
    </script>
</body>
</html>
